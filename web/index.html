<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Valhalla Debug</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.css" rel="stylesheet" />
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      height: 100vh;
    }

    #map {
      flex: 1;
      position: relative;
    }

    #sidebar {
      width: 300px;
      padding: 10px;
      background: white;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      z-index: 2;
      display: flex;
      flex-direction: column;
    }

    textarea,
    input,
    button,
    label,
    select {
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 10px;
      padding: 5px;
    }

    button {
      margin-top: auto;
    }

    #error-message {
      color: red;
      font-weight: bold;
    }

    .popup-content {
      max-width: 600px;
      max-height: 400px;
      overflow-y: auto;
    }

    .locations-container {
      width: 100%;
      height: 200px;
      border: 1px solid #ccc;
      overflow-y: auto;
      padding: 5px;
      box-sizing: border-box;
    }

    .location-row {
      display: flex;
    }

    .location-row input {
      height: 24px;
      margin-right: 5px;
    }

    .bad-input {
      background-color: #ffcccc;
    }

    .location-row span {
      cursor: pointer;
      font-size: 1.5em;
      line-height: 1;
    }

    .location-row .draggable-indicator {
      cursor: move;
      display: flex;
      margin-right: 5px;
      line-height: 1;
    }
  </style>
</head>

<body>
  <div id="sidebar">
    <div id="locations-container" class="locations-container" contenteditable="true"></div>
    <textarea id="parameters" rows="25" placeholder="Enter parameters JSON here...">
{"units":"kilometers","date_time":{"type":"current"},"costing":"auto","costing_options":{"auto":{"use_ferry":0.5,"use_rail_ferry":0.5,"use_highways":0.5,"use_tolls":0.5,"country_crossing_cost":0}}}</textarea>
    <div>
      <button id="do-route">Do route</button>
      <button id="do-expansion">Do expansion</button>
      <label for="slider">Graph expansion progress:</label>
      <input id="slider" type="range" min="0" max="1.0" value="1.0" step="0.001" />
      <label id="edges-count">Explored 0 edges</label>
      <div>
        <label for="route-summary">Route summary:</label>
        <textarea id="route-summary" rows="11" cols="50"></textarea>
      </div>
      <button id="do-traffic">Show traffic</button>
      <button id="do-clear">Clear</button>
    </div>
    <div id="error-message"></div>
  </div>
  <div id="map"></div>
  <script>
    mapboxgl.accessToken = "{{MAPBOX_ACCESS_TOKEN}}";
    const map = new mapboxgl.Map({
      container: "map",
      style: "mapbox://styles/mapbox/streets-v11",
      center: [13.15792, 55.668221],
      zoom: 11,
    });

    map.on("load", function () {
      map.addSource("route", {
        type: "geojson",
        data: {
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: []
          }
        }
      });
      map.addLayer({
        id: "route-line",
        type: "line",
        source: "route",
        layout: {
          "line-join": "round",
          "line-cap": "round",
        },
        paint: {
          "line-color": "#007AFF",
          "line-width": 9,
        }
      });

      // Source for drawing traffic lines based on information from /locate response
      map.addSource("traffic-lines", {
        type: "geojson",
        data: {
          type: "FeatureCollection",
          features: [],
        },
      });
      map.addLayer({
        id: "traffic-lines",
        type: "line",
        source: "traffic-lines",
        layout: {},
        paint: {
          // Set the line color based on the jam factor
          "line-color": [
            "interpolate",
            ["linear"],
            ["get", "jamFactor"], // Access the jam factor property
            0.0, "#33cc33", // Green for no traffic
            2.5, "#ffcc00", // Yellow for moderate traffic
            5.0, "#ffb700", // Orange for medium traffic
            7.5, "#ff0000", // Red for heavy traffic
            10., "#000000", // Black for blocked roads
          ],
          "line-width": 5,
        }
      });

      map.addSource("locate-edge", {
        type: "geojson",
        data: {
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: []
          }
        }
      });
      map.addLayer({
        id: "locate-edge",
        type: "line",
        source: "locate-edge",
        layout: {
          "line-join": "round",
          "line-cap": "round",
        },
        paint: {
          "line-color": "#E60001",
          "line-width": 5,
        }
      });

      // This source will be filled by data later in the button callback handler
      map.addSource("expansion", {
        type: "geojson",
        data: {
          type: "FeatureCollection",
          features: [],
        },
      });
      map.addLayer({
        id: "expansion-edges",
        type: "line",
        source: "expansion",
        layout: {},
        paint: {
          "line-color": [
            "interpolate",
            ["linear"],
            ["get", "progress"],
            // From Violet-Pink Gradient color scheme for progress
            0.0, "#AF1281", // Start color
            0.5, "#CF268A",
            1.0, "#E65C9C", // End color
          ],
          // Interpolate width to show if same line is covered multiple times
          "line-width": [
            "interpolate",
            ["linear"],
            ["get", "progress"],
            0,
            3, // Start width
            1.0, // progress is changing from 0.0 to 1.0
            1, // End width
          ],
        },
      });

      // Function to update the visibility of lines based on slider value
      const showLinesForProgress = (progress) => {
        map.setFilter("expansion-edges", ["<=", ["get", "progress"], progress]);
      };

      // Initial update with the full range of lines
      showLinesForProgress(1.0);

      // Event listener for the slider
      document.getElementById("slider").addEventListener("input", (event) => {
        const value = parseFloat(event.target.value);
        showLinesForProgress(value);
      });

      map.on("contextmenu", (e) => {
        const locations = [
          {
            lat: e.lngLat.lat,
            lon: e.lngLat.lng,
            radius: 500.0, // unfortunately bigger numbers give nothing
          },
        ];

        sendValhallaRequest("locate", locations, { verbose: true })
          .then((response) => response.json())
          .then((data) => {
            let edge;
            let popup_coord;
            try {
              edge = data[0]["edges"][0];
              popup_coord = [edge["correlated_lon"], edge["correlated_lat"]];
            } catch {
              edge = data;
              popup_coord = e.lngLat;
            }
            const popupContent = `<div class="popup-content">
                  <pre>${JSON.stringify(edge, null, 2)}</pre>
              </div>`;
            new mapboxgl.Popup().setLngLat(popup_coord).setHTML(popupContent).addTo(map);

            map.getSource("locate-edge").setData({
              type: "Feature",
              geometry: {
                type: "LineString",
                coordinates: decodePolyline6(edge["edge_info"]["shape"]),
              }
            });
          })
          .catch((err) => {
            console.error("Bad /locate response: ", err);
            const popup = new mapboxgl.Popup()
              .setLngLat(e.lngLat)
              .setHTML(`<p>Bad <b>/locate</b> response: ${err.message}</p>`)
              .addTo(map);
          });
      });

      document.getElementById("do-route").addEventListener("click", () => {
        const errorMessage = document.getElementById("error-message");
        const locations = locationsManager.locations;

        if (locations.length < 2) {
          errorMessage.textContent = "At least 2 locations are required";
          return;
        }

        // clear the previous lines to clearly indicate that new request is in progress
        map.getSource("expansion").setData({
          type: "FeatureCollection",
          features: [],
        });

        // Set empty data
        map.getSource("route").setData({
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: []
          }
        });

        document.getElementById("route-summary").textContent = "";

        sendValhallaRequest("route", locations, {})
          .then((response) => response.json())
          .then((data) => {
            // Draw route polyline
            map.getSource("route").setData({
              type: "Feature",
              geometry: {
                type: "LineString",
                coordinates: data["trip"]["legs"].map((leg) => decodePolyline6(leg["shape"])).flat()
              }
            });

            // Show route summary
            let summary = "";
            for (const [key, value] of Object.entries(data["trip"]["summary"])) {
              summary += `"${key}": ${JSON.stringify(value)}\n`
            }
            document.getElementById("route-summary").textContent = summary;

            // Clear error message
            errorMessage.textContent = "";
          })
          .catch((err) => {
            errorMessage.textContent = "Bad /route response: " + err;
          });
      });


      document.getElementById("do-expansion").addEventListener("click", () => {
        const errorMessage = document.getElementById("error-message");
        const locations = locationsManager.locations;

        if (locations.length < 2) {
          errorMessage.textContent = "At least 2 locations are required";
          return;
        }

        // clear the previous lines to clearly indicate that new request is in progress
        map.getSource("expansion").setData({
          type: "FeatureCollection",
          features: [],
        });

        document.getElementById("edges-count").textContent = "Exploring...";
        sendValhallaRequest("expansion", locations, { action: "route" })
          .then((response) => response.json())
          .then((data) => {
            if (!data.type || data.type !== "FeatureCollection") {
              errorMessage.textContent = "Invalid /expansion response: " + JSON.stringify(data);
              return;
            }

            // progress is changing from 0.0 for the first line to the 1.0 for the last line
            const total = data.features.length - 1;
            document.getElementById("edges-count").textContent = `Explored ${total} edges`;
            data.features.forEach((feature, i) => {
              feature.properties.progress = i / total;
            });
            map.getSource("expansion").setData(data);

            // Reset the slider and show all lines
            document.getElementById("slider").value = 1.0;
            showLinesForProgress(1.0);

            // Clear error message
            errorMessage.textContent = "";
          })
          .catch((err) => {
            errorMessage.textContent = "Bad /expansion response: " + err;
          });
      });

      document.getElementById("do-traffic").addEventListener("click", () => {
        const bounds = map.getBounds();
        const bbox = `${bounds.getSouth()},${bounds.getWest()};${bounds.getNorth()},${bounds.getEast()}`;
        // todo: probably we want to limit road graph level based on a zoom level

        fetch(`/api/traffic/${bbox}`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        })
          .then((response) => response.json())
          .then((data) => {
            const features = Object.entries(data).map(([shape, jamFactor]) => {
              return {
                type: "Feature",
                geometry: {
                  type: "LineString",
                  coordinates: decodePolyline6(shape),
                },
                properties: {
                  jamFactor: jamFactor,
                },
              };
            });
            // Update the traffic-lines source with the new data
            map.getSource("traffic-lines").setData({
              type: "FeatureCollection",
              features: features,
            });

            // Clear error message
            errorMessage.textContent = "";
          })
          .catch((err) => {
            errorMessage.textContent = "Bad /api/traffic/ response: " + err;
          });
      });

      document.getElementById("do-clear").addEventListener("click", () => {
        map.getSource("route").setData({
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: []
          }
        });
        map.getSource("locate-edge").setData({
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: [],
          }
        });
        map.getSource("expansion").setData({
          type: "FeatureCollection",
          features: [],
        });
        map.getSource("traffic-lines").setData({
          type: "FeatureCollection",
          features: [],
        });
        document.getElementById("route-summary").textContent = "";
        document.getElementById("error-message").textContent = "";
      })
    });

    function sendValhallaRequest(endpoint, locations, addons) {
      const parametersInput = document.getElementById("parameters").value;
      const errorMessage = document.getElementById("error-message");

      let parameters;
      try {
        parameters = JSON.parse(parametersInput);
      } catch (e) {
        errorMessage.textContent = "Invalid Parameters JSON.";
        return;
      }

      return fetch("/api/request", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          endpoint: endpoint,
          payload: {
            locations: locations,
            ...addons,
            ...parameters,
          },
        }),
      });
    }

    function displayLocations(locations) {
      document.getElementById("locations").value = JSON.stringify(locations, function (key, value) {
        // limit precision of floats
        if (typeof value === 'number') {
          return parseFloat(value.toFixed(5));
        }
        return value;
      });
    }

    // Decodes polyline into array of [lon, lat] points
    function decodePolyline6(encoded) {
      let currentPosition = 0;
      const len = encoded.length;

      function zigzagDecode(val) {
        return ((val & 1) ? ~(val >> 1) : (val >> 1));
      }

      function readVarint() {
        let shift = 0;
        let result = 0;
        let byte;

        do {
          byte = encoded.charCodeAt(currentPosition++) - 63;
          result |= (byte & 0x1f) << shift;
          shift += 5;
        } while (byte >= 0x20);

        return result;
      }

      let lat = 0;
      let lng = 0;
      const coordinates = [];
      while (currentPosition < len) {
        lat += zigzagDecode(readVarint());
        lng += zigzagDecode(readVarint());
        coordinates.push([lng * 1e-6, lat * 1e-6]);  // Use 1e-6 for Polyline6
      }

      return coordinates;
    }

    // Fast approximate distance between two [lon, lat] points
    function calcShortDist(from, to) {
      // Earth's radius in meters
      const R = 6371000.0;
      // Convert degrees to radians
      const lat1Rad = from[1] * Math.PI / 180;
      const lat2Rad = to[1] * Math.PI / 180;
      const lonDiffRad = (from[0] - to[0]) * Math.PI / 180;

      // Calculate the approximate shortest-distance path
      return 2.0 * Math.PI * R * Math.sqrt(
        (Math.cos(lat2Rad) * Math.abs(lonDiffRad) / (2 * Math.PI)) ** 2 +
        (Math.abs(from[1] - to[1]) / 360) ** 2
      );
    }

    // Converts edge from the "/locate" response to the geojson feature that represents traffic flow
    function to_traffic_flow(edge) {
      const edgeLiveSpeed = edge["live_speed"];
      if (!edgeLiveSpeed || !("breakpoint_0" in edgeLiveSpeed) || !("breakpoint_1" in edgeLiveSpeed)) {
        return null; // Return early if live_speed is missing
      }

      // Split edge into 3 pieces
      const length = edge["edge"]["geo_attributes"]["length"];
      const shape = decodePolyline6(edge["edge_info"]["shape"]);
      const breakpoint_0 = length * (edgeLiveSpeed["breakpoint_0"] || 0.0);
      const breakpoint_1 = length * (edgeLiveSpeed["breakpoint_1"] || 0.0);
      const { speed_0, speed_1, speed_2 } = edgeLiveSpeed; // Destructure speeds
      let segments = [];
      let traversed = 0.0
      let breakpoint_0_index = 0;
      for (let i = 0; i < shape.length - 1; i++) {
        const step = calcShortDist(shape[i], shape[i + 1]);
        if (speed_0 != speed_1 && traversed < breakpoint_0 && breakpoint_0 <= traversed + step) {
          segments.push([speed_0, shape.slice(0, i + 2)]);
          breakpoint_0_index = i + 1;
        }
        if (traversed < breakpoint_1 && breakpoint_1 <= traversed + step) {
          if (speed_1 != speed_2) {
            segments.push([speed_1, shape.slice(breakpoint_0_index, i + 1)]);
            segments.push([speed_2, shape.slice(i)]);
          } else {
            segments.push([speed_2, shape.slice(breakpoint_0_index)]);
          }
          break;
        }
        traversed += step;
      }

      // Extract speed limit
      const edgeInfo = edge["edge_info"];
      let speedLimit = edgeInfo["speed_limit"];
      if (speedLimit === "unlimited" || speedLimit === 255 || speedLimit === 0) {
        speedLimit = null; // 0 means unknown and 255 is unlimited. Both are not meaningful in our case
      }

      // Determine which speed to use for comparison
      const edgeSpeeds = edge["edge"]["speeds"];
      const freeFlowSpeed = speedLimit ?? (edgeSpeeds["free_flow"] || edgeSpeeds["default"]);

      // Return the GeoJSON feature for every segment
      return segments.map(segment => {
        return {
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: segment[1],
          },
          properties: {
            jamFactor: 10.0 - 10.0 * Math.min(segment[0] / freeFlowSpeed, 1.0),
          },
        };
      });
    }

    // Class that manages locations and markers and updates them and UI on every change
    class LocationsManager {
      constructor(map) {
        this.map = map;
        this.locations = [];
        this.markers = [];
        this.containerElement = document.getElementById("locations-container");
        this.init();
      }

      init() {
        this.containerElement.addEventListener("click", (e) => {
          if (e.target === this.containerElement) {
            this.addLocation();
          }
        });
        this.map.on('click', (e) => this.addLocationFromMap(e.lngLat));
        this.containerElement.addEventListener("input", (e) => this.updateLocationFromList(e));
        this.containerElement.addEventListener("dragstart", (e) => this.dragStart(e));
        this.containerElement.addEventListener("dragover", (e) => this.dragOver(e));
        this.containerElement.addEventListener("drop", (e) => this.drop(e));
      }

      addLocationFromMap(lngLat) {
        const newLocation = { lon: lngLat.lng.toFixed(6), lat: lngLat.lat.toFixed(6), type: 'break' };
        this.locations.push(newLocation);
        this.updateUI();
      }

      addLocation() {
        const center = this.map.getCenter();
        const newLocation = { lon: center.lng.toFixed(6), lat: center.lat.toFixed(6), type: 'break' };
        this.locations.push(newLocation);
        this.updateUI();
      }

      updateLocationFromList(e) {
        const index = e.target.dataset.index;
        const parts = value.split(',');
        if (parts.length !== 2) {
          e.target.closest('.location-row').classList.add('bad-input');
          return;
        }

        const [lat, lon] = parts.map(Number);
        if (isNaN(lat) || isNaN(lon)) {
          e.target.closest('.location-row').classList.add('bad-input');
          return;
        }

        e.target.closest('.location-row').classList.remove('bad-input');
        this.locations[index] = { lon: lon.toFixed(6), lat: lat.toFixed(6), type: 'break' };
        this.updateMarkers();
      }

      updateMarkers() {
        this.markers.forEach(marker => marker.remove());
        this.markers = this.locations.map((location, index) => {
          const color = index === 0 ? "green" : index === this.locations.length - 1 ? "red" : "gray";
          const marker = new mapboxgl.Marker({ color: color, draggable: true })
            .setLngLat([location.lon, location.lat])
            .addTo(this.map);
          marker.on('dragend', () => {
            const newCoords = marker.getLngLat();
            this.locations[index] = { lon: newCoords.lng.toFixed(6), lat: newCoords.lat.toFixed(6), type: 'break' };
            this.updateUI();
          });
          return marker;
        });
      }

      updateUI() {
        this.containerElement.innerHTML = this.locations.map((location, index) => `
      <div data-index="${index}" class="location-row" draggable="true">
        <span class="draggable-indicator" data-index="${index}">≡</span>
        <input type="text" data-index="${index}" value="${location.lat},${location.lon}" />
        <span data-index="${index}" onclick="locationsManager.removeLocation(${index})">✖</span>
      </div>
    `).join('');
        this.updateMarkers();
      }

      removeLocation(index) {
        this.locations.splice(index, 1);
        this.updateUI();

        // Reset route and expansion graph if waypoints are removed
        map.getSource("expansion").setData({
          type: "FeatureCollection",
          features: [],
        });
        map.getSource("route").setData({
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: []
          }
        });
      }

      dragStart(e) {
        if (e.target.classList.contains('draggable-indicator')) {
          e.dataTransfer.setData("text/plain", e.target.dataset.index);
        }
      }

      dragOver(e) {
        e.preventDefault();
      }

      drop(e) {
        e.preventDefault();
        const fromIndex = e.dataTransfer.getData("text/plain");
        const toIndex = e.target.closest('div').dataset.index;
        const [movedItem] = this.locations.splice(fromIndex, 1);
        this.locations.splice(toIndex, 0, movedItem);
        this.updateUI();
      }
    }

    const locationsManager = new LocationsManager(map);
  </script>
</body>

</html>
